// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addDomainToOrg = `-- name: AddDomainToOrg :one
INSERT INTO org_domains (org_id, domain)
VALUES (
    $1,
    $2
  ) ON CONFLICT (org_id, domain) DO NOTHING
RETURNING org_id, domain, verified, auto_join_enabled, created_at, updated_at
`

type AddDomainToOrgParams struct {
	OrgID  uuid.UUID `db:"org_id" json:"orgId"`
	Domain string    `db:"domain" json:"domain"`
}

func (q *Queries) AddDomainToOrg(ctx context.Context, arg AddDomainToOrgParams) (OrgDomain, error) {
	row := q.db.QueryRow(ctx, addDomainToOrg, arg.OrgID, arg.Domain)
	var i OrgDomain
	err := row.Scan(
		&i.OrgID,
		&i.Domain,
		&i.Verified,
		&i.AutoJoinEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const banUserFromOrg = `-- name: BanUserFromOrg :exec
UPDATE user_orgs
SET STATUS = 'banned'
WHERE user_id = $1
  AND org_id = $2
`

type BanUserFromOrgParams struct {
	UserID uuid.UUID `db:"user_id" json:"userId"`
	OrgID  uuid.UUID `db:"org_id" json:"orgId"`
}

func (q *Queries) BanUserFromOrg(ctx context.Context, arg BanUserFromOrgParams) error {
	_, err := q.db.Exec(ctx, banUserFromOrg, arg.UserID, arg.OrgID)
	return err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (
    id,
    org_id,
    email,
    role,
    invited_by,
    token,
    expires_at
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
  )
RETURNING id, org_id, email, role, invited_by, token, expires_at, accepted_at, created_at, status
`

type CreateInvitationParams struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	OrgID     uuid.UUID          `db:"org_id" json:"orgId"`
	Email     string             `db:"email" json:"email"`
	Role      string             `db:"role" json:"role"`
	InvitedBy *uuid.UUID         `db:"invited_by" json:"invitedBy"`
	Token     string             `db:"token" json:"token"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expiresAt"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.db.QueryRow(ctx, createInvitation,
		arg.ID,
		arg.OrgID,
		arg.Email,
		arg.Role,
		arg.InvitedBy,
		arg.Token,
		arg.ExpiresAt,
	)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const createOrg = `-- name: CreateOrg :one
INSERT INTO orgs (
    id,
    slug,
    name,
    description,
    avatar_url,
    settings
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
  ) ON CONFLICT (slug) DO NOTHING
RETURNING id, slug, name, description, avatar_url, settings, created_at, updated_at, deleted_at
`

type CreateOrgParams struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Slug        string    `db:"slug" json:"slug"`
	Name        string    `db:"name" json:"name"`
	Description *string   `db:"description" json:"description"`
	AvatarUrl   *string   `db:"avatar_url" json:"avatarUrl"`
	Settings    []byte    `db:"settings" json:"settings"`
}

func (q *Queries) CreateOrg(ctx context.Context, arg CreateOrgParams) (Org, error) {
	row := q.db.QueryRow(ctx, createOrg,
		arg.ID,
		arg.Slug,
		arg.Name,
		arg.Description,
		arg.AvatarUrl,
		arg.Settings,
	)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    id,
    user_id,
    org_id,
    token_hash,
    refresh_token_hash,
    mfa_verified,
    ip_address,
    user_agent,
    mfa_verified_at,
    expires_at
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
  )
RETURNING id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
`

type CreateSessionParams struct {
	ID               uuid.UUID          `db:"id" json:"id"`
	UserID           uuid.UUID          `db:"user_id" json:"userId"`
	OrgID            uuid.UUID          `db:"org_id" json:"orgId"`
	TokenHash        string             `db:"token_hash" json:"tokenHash"`
	RefreshTokenHash string             `db:"refresh_token_hash" json:"refreshTokenHash"`
	MfaVerified      bool               `db:"mfa_verified" json:"mfaVerified"`
	IpAddress        netip.Addr         `db:"ip_address" json:"ipAddress"`
	UserAgent        string             `db:"user_agent" json:"userAgent"`
	MfaVerifiedAt    pgtype.Timestamptz `db:"mfa_verified_at" json:"mfaVerifiedAt"`
	ExpiresAt        pgtype.Timestamptz `db:"expires_at" json:"expiresAt"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.OrgID,
		arg.TokenHash,
		arg.RefreshTokenHash,
		arg.MfaVerified,
		arg.IpAddress,
		arg.UserAgent,
		arg.MfaVerifiedAt,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.MfaVerified,
		&i.IpAddress,
		&i.UserAgent,
		&i.MfaVerifiedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    id,
    email,
    password_hash,
    first_name,
    last_name,
    avatar_url
  )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
  )
RETURNING id,
  email,
  email_verified,
  first_name,
  last_name,
  avatar_url,
  created_at,
  updated_at
`

type CreateUserParams struct {
	ID           uuid.UUID `db:"id" json:"id"`
	Email        string    `db:"email" json:"email"`
	PasswordHash *string   `db:"password_hash" json:"passwordHash"`
	FirstName    *string   `db:"first_name" json:"firstName"`
	LastName     *string   `db:"last_name" json:"lastName"`
	AvatarUrl    *string   `db:"avatar_url" json:"avatarUrl"`
}

type CreateUserRow struct {
	ID            uuid.UUID          `db:"id" json:"id"`
	Email         string             `db:"email" json:"email"`
	EmailVerified bool               `db:"email_verified" json:"emailVerified"`
	FirstName     *string            `db:"first_name" json:"firstName"`
	LastName      *string            `db:"last_name" json:"lastName"`
	AvatarUrl     *string            `db:"avatar_url" json:"avatarUrl"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.AvatarUrl,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const deleteSessionByRefreshToken = `-- name: DeleteSessionByRefreshToken :exec
DELETE FROM sessions
WHERE refresh_token_hash = $1
`

func (q *Queries) DeleteSessionByRefreshToken(ctx context.Context, refreshTokenHash string) error {
	_, err := q.db.Exec(ctx, deleteSessionByRefreshToken, refreshTokenHash)
	return err
}

const deleteSessionByToken = `-- name: DeleteSessionByToken :exec
DELETE FROM sessions
WHERE token_hash = $1
`

func (q *Queries) DeleteSessionByToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, deleteSessionByToken, tokenHash)
	return err
}

const getInfoForSessionRefresh = `-- name: GetInfoForSessionRefresh :one
SELECT u.first_name AS user_fname,
  u.last_name AS user_lname,
  u.email AS user_email,
  u.email_verified AS user_email_verified,
  u.avatar_url AS user_avatar_url,
  o.name AS org_name,
  o.slug AS org_slug,
  uo.role AS user_org_role
FROM users u
  INNER JOIN user_orgs uo ON u.id = uo.user_id
  INNER JOIN orgs o ON o.id = uo.org_id
WHERE u.id = $1
  AND o.id = $2
  AND uo.status != 'banned'
`

type GetInfoForSessionRefreshParams struct {
	UserID uuid.UUID `db:"user_id" json:"userId"`
	OrgID  uuid.UUID `db:"org_id" json:"orgId"`
}

type GetInfoForSessionRefreshRow struct {
	UserFname         *string `db:"user_fname" json:"userFname"`
	UserLname         *string `db:"user_lname" json:"userLname"`
	UserEmail         string  `db:"user_email" json:"userEmail"`
	UserEmailVerified bool    `db:"user_email_verified" json:"userEmailVerified"`
	UserAvatarUrl     *string `db:"user_avatar_url" json:"userAvatarUrl"`
	OrgName           string  `db:"org_name" json:"orgName"`
	OrgSlug           string  `db:"org_slug" json:"orgSlug"`
	UserOrgRole       string  `db:"user_org_role" json:"userOrgRole"`
}

func (q *Queries) GetInfoForSessionRefresh(ctx context.Context, arg GetInfoForSessionRefreshParams) (GetInfoForSessionRefreshRow, error) {
	row := q.db.QueryRow(ctx, getInfoForSessionRefresh, arg.UserID, arg.OrgID)
	var i GetInfoForSessionRefreshRow
	err := row.Scan(
		&i.UserFname,
		&i.UserLname,
		&i.UserEmail,
		&i.UserEmailVerified,
		&i.UserAvatarUrl,
		&i.OrgName,
		&i.OrgSlug,
		&i.UserOrgRole,
	)
	return i, err
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT id, org_id, email, role, invited_by, token, expires_at, accepted_at, created_at, status
FROM invitations
WHERE id = $1
  AND expires_at > NOW()
`

func (q *Queries) GetInvitationByID(ctx context.Context, id uuid.UUID) (Invitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByID, id)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const getInvitationByIDUnsafe = `-- name: GetInvitationByIDUnsafe :one
SELECT id, org_id, email, role, invited_by, token, expires_at, accepted_at, created_at, status
FROM invitations
WHERE id = $1
`

func (q *Queries) GetInvitationByIDUnsafe(ctx context.Context, id uuid.UUID) (Invitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByIDUnsafe, id)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const getInvitationByToken = `-- name: GetInvitationByToken :one
SELECT id, org_id, email, role, invited_by, token, expires_at, accepted_at, created_at, status
FROM invitations
WHERE token = $1
  AND expires_at > NOW()
`

func (q *Queries) GetInvitationByToken(ctx context.Context, token string) (Invitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByToken, token)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const getInvitationByTokenUnsafe = `-- name: GetInvitationByTokenUnsafe :one
SELECT id, org_id, email, role, invited_by, token, expires_at, accepted_at, created_at, status
FROM invitations
WHERE token = $1
`

func (q *Queries) GetInvitationByTokenUnsafe(ctx context.Context, token string) (Invitation, error) {
	row := q.db.QueryRow(ctx, getInvitationByTokenUnsafe, token)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Email,
		&i.Role,
		&i.InvitedBy,
		&i.Token,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
		&i.Status,
	)
	return i, err
}

const getLoginInfoForUser = `-- name: GetLoginInfoForUser :one
SELECT id, email, email_verified, password_hash, backup_codes, first_name, last_name, avatar_url, created_at, updated_at, deleted_at
FROM users
WHERE email = $1
`

func (q *Queries) GetLoginInfoForUser(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getLoginInfoForUser, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.BackupCodes,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrgByDomain = `-- name: GetOrgByDomain :one
SELECT o.id, o.slug, o.name, o.description, o.avatar_url, o.settings, o.created_at, o.updated_at, o.deleted_at
FROM orgs o
  INNER JOIN org_domains od ON o.id = od.org_id
WHERE od.domain = $1
`

func (q *Queries) GetOrgByDomain(ctx context.Context, domain string) (Org, error) {
	row := q.db.QueryRow(ctx, getOrgByDomain, domain)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrgByID = `-- name: GetOrgByID :one
SELECT id, slug, name, description, avatar_url, settings, created_at, updated_at, deleted_at
FROM orgs
WHERE id = $1
`

func (q *Queries) GetOrgByID(ctx context.Context, id uuid.UUID) (Org, error) {
	row := q.db.QueryRow(ctx, getOrgByID, id)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrgBySlug = `-- name: GetOrgBySlug :one
SELECT id, slug, name, description, avatar_url, settings, created_at, updated_at, deleted_at
FROM orgs
WHERE slug = $1
`

func (q *Queries) GetOrgBySlug(ctx context.Context, slug string) (Org, error) {
	row := q.db.QueryRow(ctx, getOrgBySlug, slug)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrgForDomainIfAutoJoin = `-- name: GetOrgForDomainIfAutoJoin :one
SELECT o.id, o.slug, o.name, o.description, o.avatar_url, o.settings, o.created_at, o.updated_at, o.deleted_at
FROM orgs o
  INNER JOIN org_domains od ON o.id = od.org_id
WHERE od.domain = $1
  AND od.auto_join_enabled = TRUE
  AND od.verified = TRUE
`

func (q *Queries) GetOrgForDomainIfAutoJoin(ctx context.Context, domain string) (Org, error) {
	row := q.db.QueryRow(ctx, getOrgForDomainIfAutoJoin, domain)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
FROM sessions
WHERE id = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.MfaVerified,
		&i.IpAddress,
		&i.UserAgent,
		&i.MfaVerifiedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByRefreshToken = `-- name: GetSessionByRefreshToken :one
SELECT id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
FROM sessions
WHERE refresh_token_hash = $1
`

func (q *Queries) GetSessionByRefreshToken(ctx context.Context, refreshTokenHash string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByRefreshToken, refreshTokenHash)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.MfaVerified,
		&i.IpAddress,
		&i.UserAgent,
		&i.MfaVerifiedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
FROM sessions
WHERE token_hash = $1
`

func (q *Queries) GetSessionByToken(ctx context.Context, tokenHash string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, tokenHash)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.MfaVerified,
		&i.IpAddress,
		&i.UserAgent,
		&i.MfaVerifiedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionsByOrgID = `-- name: GetSessionsByOrgID :many
SELECT id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
FROM sessions
WHERE org_id = $1
`

func (q *Queries) GetSessionsByOrgID(ctx context.Context, orgID uuid.UUID) ([]Session, error) {
	rows, err := q.db.Query(ctx, getSessionsByOrgID, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrgID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.MfaVerified,
			&i.IpAddress,
			&i.UserAgent,
			&i.MfaVerifiedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsByUserID = `-- name: GetSessionsByUserID :many
SELECT id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
FROM sessions
WHERE user_id = $1
`

func (q *Queries) GetSessionsByUserID(ctx context.Context, userID uuid.UUID) ([]Session, error) {
	rows, err := q.db.Query(ctx, getSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrgID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.MfaVerified,
			&i.IpAddress,
			&i.UserAgent,
			&i.MfaVerifiedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsByUserIDAndOrgID = `-- name: GetSessionsByUserIDAndOrgID :many
SELECT id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
FROM sessions
WHERE user_id = $1
  AND org_id = $2
`

type GetSessionsByUserIDAndOrgIDParams struct {
	UserID uuid.UUID `db:"user_id" json:"userId"`
	OrgID  uuid.UUID `db:"org_id" json:"orgId"`
}

func (q *Queries) GetSessionsByUserIDAndOrgID(ctx context.Context, arg GetSessionsByUserIDAndOrgIDParams) ([]Session, error) {
	rows, err := q.db.Query(ctx, getSessionsByUserIDAndOrgID, arg.UserID, arg.OrgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrgID,
			&i.TokenHash,
			&i.RefreshTokenHash,
			&i.MfaVerified,
			&i.IpAddress,
			&i.UserAgent,
			&i.MfaVerifiedAt,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id,
  email,
  email_verified,
  first_name,
  last_name,
  avatar_url,
  created_at,
  updated_at
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID            uuid.UUID          `db:"id" json:"id"`
	Email         string             `db:"email" json:"email"`
	EmailVerified bool               `db:"email_verified" json:"emailVerified"`
	FirstName     *string            `db:"first_name" json:"firstName"`
	LastName      *string            `db:"last_name" json:"lastName"`
	AvatarUrl     *string            `db:"avatar_url" json:"avatarUrl"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id,
  email,
  email_verified,
  first_name,
  last_name,
  avatar_url,
  created_at,
  updated_at
FROM users
WHERE id = $1
`

type GetUserByIDRow struct {
	ID            uuid.UUID          `db:"id" json:"id"`
	Email         string             `db:"email" json:"email"`
	EmailVerified bool               `db:"email_verified" json:"emailVerified"`
	FirstName     *string            `db:"first_name" json:"firstName"`
	LastName      *string            `db:"last_name" json:"lastName"`
	AvatarUrl     *string            `db:"avatar_url" json:"avatarUrl"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserOrgsByEmail = `-- name: GetUserOrgsByEmail :many
SELECT o.id, o.slug, o.name, o.description, o.avatar_url, o.settings, o.created_at, o.updated_at, o.deleted_at,
  uo.user_id, uo.org_id, uo.role, uo.joined_at, uo.last_active_at, uo.status
FROM orgs o
  INNER JOIN user_orgs uo ON o.id = uo.org_id
  INNER JOIN users u ON u.id = uo.user_id
WHERE u.email = $1
`

type GetUserOrgsByEmailRow struct {
	Org     Org     `db:"org" json:"org"`
	UserOrg UserOrg `db:"user_org" json:"userOrg"`
}

func (q *Queries) GetUserOrgsByEmail(ctx context.Context, email *string) ([]GetUserOrgsByEmailRow, error) {
	rows, err := q.db.Query(ctx, getUserOrgsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserOrgsByEmailRow{}
	for rows.Next() {
		var i GetUserOrgsByEmailRow
		if err := rows.Scan(
			&i.Org.ID,
			&i.Org.Slug,
			&i.Org.Name,
			&i.Org.Description,
			&i.Org.AvatarUrl,
			&i.Org.Settings,
			&i.Org.CreatedAt,
			&i.Org.UpdatedAt,
			&i.Org.DeletedAt,
			&i.UserOrg.UserID,
			&i.UserOrg.OrgID,
			&i.UserOrg.Role,
			&i.UserOrg.JoinedAt,
			&i.UserOrg.LastActiveAt,
			&i.UserOrg.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrgsByID = `-- name: GetUserOrgsByID :many
SELECT o.id,
  o.slug,
  o.name,
  o.description,
  o.avatar_url
FROM orgs o
  INNER JOIN user_orgs uo ON o.id = uo.org_id
  INNER JOIN users u ON u.id = uo.user_id
WHERE u.id = $1
`

type GetUserOrgsByIDRow struct {
	ID          uuid.UUID `db:"id" json:"id"`
	Slug        string    `db:"slug" json:"slug"`
	Name        string    `db:"name" json:"name"`
	Description *string   `db:"description" json:"description"`
	AvatarUrl   *string   `db:"avatar_url" json:"avatarUrl"`
}

func (q *Queries) GetUserOrgsByID(ctx context.Context, id *uuid.UUID) ([]GetUserOrgsByIDRow, error) {
	rows, err := q.db.Query(ctx, getUserOrgsByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserOrgsByIDRow{}
	for rows.Next() {
		var i GetUserOrgsByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Description,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVerificationTokenByHash = `-- name: GetVerificationTokenByHash :one
SELECT id, user_id, type, token_hash, expires_at, created_at
FROM verification_tokens
WHERE token_hash = $1
  AND expires_at > NOW()
`

func (q *Queries) GetVerificationTokenByHash(ctx context.Context, tokenHash []byte) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, getVerificationTokenByHash, tokenHash)
	var i VerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const linkUserToOrg = `-- name: LinkUserToOrg :exec
INSERT INTO user_orgs (user_id, org_id, role)
VALUES (
    $1,
    $2,
    coalesce($3, 'member')
  )
`

type LinkUserToOrgParams struct {
	UserID uuid.UUID   `db:"user_id" json:"userId"`
	OrgID  uuid.UUID   `db:"org_id" json:"orgId"`
	Role   interface{} `db:"role" json:"role"`
}

func (q *Queries) LinkUserToOrg(ctx context.Context, arg LinkUserToOrgParams) error {
	_, err := q.db.Exec(ctx, linkUserToOrg, arg.UserID, arg.OrgID, arg.Role)
	return err
}

const markUserEmailVerified = `-- name: MarkUserEmailVerified :exec
UPDATE users
SET email_verified = TRUE,
  updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkUserEmailVerified(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markUserEmailVerified, id)
	return err
}

const newVerificationToken = `-- name: NewVerificationToken :one
INSERT INTO verification_tokens (
    id,
    user_id,
    TYPE,
    token_hash,
    expires_at
  )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, type, token_hash, expires_at, created_at
`

type NewVerificationTokenParams struct {
	ID        uuid.UUID          `db:"id" json:"id"`
	UserID    uuid.UUID          `db:"user_id" json:"userId"`
	Type      string             `db:"type" json:"type"`
	TokenHash []byte             `db:"token_hash" json:"tokenHash"`
	ExpiresAt pgtype.Timestamptz `db:"expires_at" json:"expiresAt"`
}

func (q *Queries) NewVerificationToken(ctx context.Context, arg NewVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, newVerificationToken,
		arg.ID,
		arg.UserID,
		arg.Type,
		arg.TokenHash,
		arg.ExpiresAt,
	)
	var i VerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const refreshSession = `-- name: RefreshSession :one
UPDATE sessions
SET token_hash = coalesce($1, token_hash),
  refresh_token_hash = coalesce(
    $2,
    refresh_token_hash
  ),
  expires_at = coalesce($3, expires_at)
WHERE id = $4
RETURNING id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
`

type RefreshSessionParams struct {
	TokenHash        *string            `db:"token_hash" json:"tokenHash"`
	RefreshTokenHash *string            `db:"refresh_token_hash" json:"refreshTokenHash"`
	ExpiresAt        pgtype.Timestamptz `db:"expires_at" json:"expiresAt"`
	ID               uuid.UUID          `db:"id" json:"id"`
}

func (q *Queries) RefreshSession(ctx context.Context, arg RefreshSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, refreshSession,
		arg.TokenHash,
		arg.RefreshTokenHash,
		arg.ExpiresAt,
		arg.ID,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.MfaVerified,
		&i.IpAddress,
		&i.UserAgent,
		&i.MfaVerifiedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const removeDomainFromOrg = `-- name: RemoveDomainFromOrg :exec
DELETE FROM org_domains
WHERE org_id = $1
  AND domain = $2
`

type RemoveDomainFromOrgParams struct {
	OrgID  uuid.UUID `db:"org_id" json:"orgId"`
	Domain string    `db:"domain" json:"domain"`
}

func (q *Queries) RemoveDomainFromOrg(ctx context.Context, arg RemoveDomainFromOrgParams) error {
	_, err := q.db.Exec(ctx, removeDomainFromOrg, arg.OrgID, arg.Domain)
	return err
}

const revokeInvitation = `-- name: RevokeInvitation :exec
DELETE FROM invitations
WHERE id = $1
`

func (q *Queries) RevokeInvitation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeInvitation, id)
	return err
}

const revokeInvitationByEmail = `-- name: RevokeInvitationByEmail :exec
DELETE FROM invitations
WHERE email = $1
  AND org_id = $2
`

type RevokeInvitationByEmailParams struct {
	Email string    `db:"email" json:"email"`
	OrgID uuid.UUID `db:"org_id" json:"orgId"`
}

func (q *Queries) RevokeInvitationByEmail(ctx context.Context, arg RevokeInvitationByEmailParams) error {
	_, err := q.db.Exec(ctx, revokeInvitationByEmail, arg.Email, arg.OrgID)
	return err
}

const revokeInvitationByToken = `-- name: RevokeInvitationByToken :exec
DELETE FROM invitations
WHERE token = $1
`

func (q *Queries) RevokeInvitationByToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, revokeInvitationByToken, token)
	return err
}

const setUserBackupCodes = `-- name: SetUserBackupCodes :exec
UPDATE users
SET backup_codes = $1,
  updated_at = NOW()
WHERE email = $2
`

type SetUserBackupCodesParams struct {
	BackupCodes []string `db:"backup_codes" json:"backupCodes"`
	Email       string   `db:"email" json:"email"`
}

func (q *Queries) SetUserBackupCodes(ctx context.Context, arg SetUserBackupCodesParams) error {
	_, err := q.db.Exec(ctx, setUserBackupCodes, arg.BackupCodes, arg.Email)
	return err
}

const softDeleteOrg = `-- name: SoftDeleteOrg :exec
UPDATE orgs
SET deleted_at = NOW(),
  updated_at = NOW()
WHERE id = $1
  AND slug != 'default'
`

func (q *Queries) SoftDeleteOrg(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteOrg, id)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET deleted_at = NOW(),
  updated_at = NOW()
WHERE email = $1
`

func (q *Queries) SoftDeleteUser(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, softDeleteUser, email)
	return err
}

const unlinkUserFromOrg = `-- name: UnlinkUserFromOrg :exec
DELETE FROM user_orgs
WHERE user_id = $1
  AND org_id = $2
`

type UnlinkUserFromOrgParams struct {
	UserID uuid.UUID `db:"user_id" json:"userId"`
	OrgID  uuid.UUID `db:"org_id" json:"orgId"`
}

func (q *Queries) UnlinkUserFromOrg(ctx context.Context, arg UnlinkUserFromOrgParams) error {
	_, err := q.db.Exec(ctx, unlinkUserFromOrg, arg.UserID, arg.OrgID)
	return err
}

const updateOrg = `-- name: UpdateOrg :one
UPDATE orgs
SET name = coalesce($1, name),
  description = coalesce($2, description),
  avatar_url = coalesce($3, avatar_url),
  settings = coalesce($4, settings),
  updated_at = NOW()
WHERE id = $5
RETURNING id, slug, name, description, avatar_url, settings, created_at, updated_at, deleted_at
`

type UpdateOrgParams struct {
	Name        *string   `db:"name" json:"name"`
	Description *string   `db:"description" json:"description"`
	AvatarUrl   *string   `db:"avatar_url" json:"avatarUrl"`
	Settings    []byte    `db:"settings" json:"settings"`
	ID          uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateOrg(ctx context.Context, arg UpdateOrgParams) (Org, error) {
	row := q.db.QueryRow(ctx, updateOrg,
		arg.Name,
		arg.Description,
		arg.AvatarUrl,
		arg.Settings,
		arg.ID,
	)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateOrgWhereSlug = `-- name: UpdateOrgWhereSlug :one
UPDATE orgs
SET name = coalesce($1, name),
  description = coalesce($2, description),
  avatar_url = coalesce($3, avatar_url),
  settings = coalesce($4, settings),
  updated_at = NOW()
WHERE slug = $5
RETURNING id, slug, name, description, avatar_url, settings, created_at, updated_at, deleted_at
`

type UpdateOrgWhereSlugParams struct {
	Name        *string `db:"name" json:"name"`
	Description *string `db:"description" json:"description"`
	AvatarUrl   *string `db:"avatar_url" json:"avatarUrl"`
	Settings    []byte  `db:"settings" json:"settings"`
	Slug        string  `db:"slug" json:"slug"`
}

func (q *Queries) UpdateOrgWhereSlug(ctx context.Context, arg UpdateOrgWhereSlugParams) (Org, error) {
	row := q.db.QueryRow(ctx, updateOrgWhereSlug,
		arg.Name,
		arg.Description,
		arg.AvatarUrl,
		arg.Settings,
		arg.Slug,
	)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.AvatarUrl,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateSessionMFA = `-- name: UpdateSessionMFA :one
UPDATE sessions
SET mfa_verified = $1,
  mfa_verified_at = $2,
  updated_at = NOW()
WHERE id = $3
RETURNING id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
`

type UpdateSessionMFAParams struct {
	MfaVerified   bool               `db:"mfa_verified" json:"mfaVerified"`
	MfaVerifiedAt pgtype.Timestamptz `db:"mfa_verified_at" json:"mfaVerifiedAt"`
	ID            uuid.UUID          `db:"id" json:"id"`
}

func (q *Queries) UpdateSessionMFA(ctx context.Context, arg UpdateSessionMFAParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionMFA, arg.MfaVerified, arg.MfaVerifiedAt, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.MfaVerified,
		&i.IpAddress,
		&i.UserAgent,
		&i.MfaVerifiedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET first_name = coalesce($1, first_name),
  last_name = coalesce($2, last_name),
  avatar_url = coalesce($3, avatar_url),
  updated_at = NOW()
WHERE email = $4
RETURNING id,
  email,
  email_verified,
  first_name,
  last_name,
  avatar_url,
  created_at,
  updated_at
`

type UpdateUserParams struct {
	FirstName *string `db:"first_name" json:"firstName"`
	LastName  *string `db:"last_name" json:"lastName"`
	AvatarUrl *string `db:"avatar_url" json:"avatarUrl"`
	Email     string  `db:"email" json:"email"`
}

type UpdateUserRow struct {
	ID            uuid.UUID          `db:"id" json:"id"`
	Email         string             `db:"email" json:"email"`
	EmailVerified bool               `db:"email_verified" json:"emailVerified"`
	FirstName     *string            `db:"first_name" json:"firstName"`
	LastName      *string            `db:"last_name" json:"lastName"`
	AvatarUrl     *string            `db:"avatar_url" json:"avatarUrl"`
	CreatedAt     pgtype.Timestamptz `db:"created_at" json:"createdAt"`
	UpdatedAt     pgtype.Timestamptz `db:"updated_at" json:"updatedAt"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.FirstName,
		arg.LastName,
		arg.AvatarUrl,
		arg.Email,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerified,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password_hash = $1,
  updated_at = NOW()
WHERE email = $2
`

type UpdateUserPasswordParams struct {
	PasswordHash *string `db:"password_hash" json:"passwordHash"`
	Email        string  `db:"email" json:"email"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.PasswordHash, arg.Email)
	return err
}

const updateUserSessionAgentAndIP = `-- name: UpdateUserSessionAgentAndIP :one
UPDATE sessions
SET user_agent = coalesce($1, user_agent),
  ip_address = coalesce($2, ip_address),
  updated_at = NOW()
WHERE id = $3
RETURNING id, user_id, org_id, token_hash, refresh_token_hash, mfa_verified, ip_address, user_agent, mfa_verified_at, expires_at, created_at
`

type UpdateUserSessionAgentAndIPParams struct {
	UserAgent *string     `db:"user_agent" json:"userAgent"`
	IpAddress *netip.Addr `db:"ip_address" json:"ipAddress"`
	ID        uuid.UUID   `db:"id" json:"id"`
}

func (q *Queries) UpdateUserSessionAgentAndIP(ctx context.Context, arg UpdateUserSessionAgentAndIPParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateUserSessionAgentAndIP, arg.UserAgent, arg.IpAddress, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrgID,
		&i.TokenHash,
		&i.RefreshTokenHash,
		&i.MfaVerified,
		&i.IpAddress,
		&i.UserAgent,
		&i.MfaVerifiedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}
